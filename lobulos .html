<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizaci√≥n de L√≥bulos y Canales Monopulso 3D</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #333;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .section-title {
            font-size: 1.8em;
            color: #2c3e50;
            margin-bottom: 20px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        
        .grid-2x2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .plot-container {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 10px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .plot-full {
            width: 100%;
            height: 600px;
        }
        
        .plot-quarter {
            width: 100%;
            height: 450px;
        }
        
        @media (max-width: 900px) {
            .grid-2x2 {
                grid-template-columns: 1fr;
            }
        }
        
        .loading {
            text-align: center;
            padding: 50px;
            color: #666;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî¨ An√°lisis de L√≥bulos y Canales Monopulso 3D</h1>
        
        <!-- Secci√≥n 1: L√≥bulos Individuales -->
        <div class="section">
            <h2 class="section-title">üìä L√≥bulos Individuales</h2>
            <div class="grid-2x2">
                <div class="plot-container">
                    <div id="lobuloA" class="plot-quarter"></div>
                </div>
                <div class="plot-container">
                    <div id="lobuloB" class="plot-quarter"></div>
                </div>
                <div class="plot-container">
                    <div id="lobuloC" class="plot-quarter"></div>
                </div>
                <div class="plot-container">
                    <div id="lobuloD" class="plot-quarter"></div>
                </div>
            </div>
        </div>
        
        <!-- Secci√≥n 2: Visualizaci√≥n 3D Combinada -->
        <div class="section">
            <h2 class="section-title">üåê Visualizaci√≥n 3D Combinada de L√≥bulos</h2>
            <div class="plot-container">
                <div id="combinados" class="plot-full"></div>
            </div>
        </div>
        
        <!-- Secci√≥n 3: Canales Monopulso 3D -->
        <div class="section">
            <h2 class="section-title">üéØ Canales Monopulso 3D (Coordenadas Esf√©ricas)</h2>
            <div class="grid-2x2">
                <div class="plot-container">
                    <div id="sigma" class="plot-quarter"></div>
                </div>
                <div class="plot-container">
                    <div id="azimut" class="plot-quarter"></div>
                </div>
                <div class="plot-container">
                    <div id="elevacion" class="plot-quarter"></div>
                </div>
                <div class="plot-container">
                    <div id="cruzado" class="plot-quarter"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // FUNCI√ìN SINC Y UTILIDADES
        // ==========================================
        
        function sinc(x) {
            if (Math.abs(x) < 1e-10) return 1;
            return Math.sin(Math.PI * x) / (Math.PI * x);
        }
        
        // Generar meshgrid
        function meshgrid(x, y) {
            const X = [], Y = [];
            for (let i = 0; i < y.length; i++) {
                X[i] = [];
                Y[i] = [];
                for (let j = 0; j < x.length; j++) {
                    X[i][j] = x[j];
                    Y[i][j] = y[i];
                }
            }
            return [X, Y];
        }
        
        // ==========================================
        // PAR√ÅMETROS INICIALES
        // ==========================================
        
        const nPoints = 100; // Reducido para mejor rendimiento (200 en MATLAB)
        const asimut = linspace(-90, 90, nPoints);
        const elevacion = linspace(-90, 90, nPoints);
        const [Asimut, Elevacion] = meshgrid(asimut, elevacion);
        
        // Funci√≥n sinc 2D
        function sinc2d(asimut, elevacion, asimut0, elevacion0) {
            const rows = asimut.length;
            const cols = asimut[0].length;
            const result = [];
            for (let i = 0; i < rows; i++) {
                result[i] = [];
                for (let j = 0; j < cols; j++) {
                    const val = sinc((asimut[i][j] - asimut0) / 20) * sinc((elevacion[i][j] - elevacion0) / 20);
                    result[i][j] = val;
                }
            }
            return result;
        }
        
        // Crear l√≥bulos individuales
        const lobulo_A = sinc2d(Asimut, Elevacion, 20, 20);
        const lobulo_B = sinc2d(Asimut, Elevacion, -20, 20);
        const lobulo_C = sinc2d(Asimut, Elevacion, 20, -20);
        const lobulo_D = sinc2d(Asimut, Elevacion, -20, -20);
        
        // Mapa de colores multicolor (azul -> cyan -> amarillo -> naranja -> rojo)
        function createMulticolorColorscale() {
            return [
                [0, 'rgb(0,0,255)'],      // Azul
                [0.25, 'rgb(0,255,255)'], // Cyan
                [0.5, 'rgb(255,255,0)'],  // Amarillo
                [0.75, 'rgb(255,128,0)'], // Naranja
                [1, 'rgb(255,0,0)']       // Rojo
            ];
        }
        
        // ==========================================
        // FIGURA 1: L√ìBULOS INDIVIDUALES (2x2)
        // ==========================================
        
        const cameraView = {
            eye: { x: 1.5, y: 1.5, z: 1.2 },
            center: { x: 0, y: 0, z: 0 },
            up: { x: 0, y: 0, z: 1 }
        };
        
        const commonLayout = {
            scene: {
                xaxis: { title: 'Asimut', gridcolor: '#ddd', backgroundcolor: '#f0f0f0' },
                yaxis: { title: 'Elevaci√≥n', gridcolor: '#ddd', backgroundcolor: '#f0f0f0' },
                zaxis: { title: 'Amplitud', gridcolor: '#ddd', backgroundcolor: '#f0f0f0' },
                camera: cameraView,
                aspectmode: 'cube'
            },
            margin: { l: 0, r: 0, b: 0, t: 40 },
            paper_bgcolor: 'rgba(0,0,0,0)',
            plot_bgcolor: 'rgba(0,0,0,0)'
        };
        
        function createSurfacePlot(zData, title, colorscale) {
            return {
                type: 'surface',
                x: Asimut,
                y: Elevacion,
                z: zData,
                colorscale: colorscale || createMulticolorColorscale(),
                showscale: true,
                contours: {
                    z: { show: false }
                },
                lighting: {
                    ambient: 0.6,
                    diffuse: 0.8,
                    specular: 0.9,
                    roughness: 0.5
                }
            };
        }
        
        // L√≥bulo A
        Plotly.newPlot('lobuloA', [createSurfacePlot(lobulo_A, 'L√≥bulo A')], {
            ...commonLayout,
            title: { text: 'L√≥bulo A', font: { size: 16, weight: 'bold' } }
        }, { responsive: true });
        
        // L√≥bulo B
        Plotly.newPlot('lobuloB', [createSurfacePlot(lobulo_B, 'L√≥bulo B')], {
            ...commonLayout,
            title: { text: 'L√≥bulo B', font: { size: 16, weight: 'bold' } }
        }, { responsive: true });
        
        // L√≥bulo C
        Plotly.newPlot('lobuloC', [createSurfacePlot(lobulo_C, 'L√≥bulo C')], {
            ...commonLayout,
            title: { text: 'L√≥bulo C', font: { size: 16, weight: 'bold' } }
        }, { responsive: true });
        
        // L√≥bulo D
        Plotly.newPlot('lobuloD', [createSurfacePlot(lobulo_D, 'L√≥bulo D')], {
            ...commonLayout,
            title: { text: 'L√≥bulo D', font: { size: 16, weight: 'bold' } }
        }, { responsive: true });
        
        // ==========================================
        // FIGURA 2: VISUALIZACI√ìN 3D COMBINADA
        // ==========================================
        
        const combinadosData = [
            {
                type: 'surface',
                x: Asimut,
                y: Elevacion,
                z: lobulo_A,
                colorscale: createMulticolorColorscale(),
                opacity: 0.7,
                showscale: false,
                name: 'L√≥bulo A',
                lighting: { ambient: 0.6, diffuse: 0.8 }
            },
            {
                type: 'surface',
                x: Asimut,
                y: Elevacion,
                z: lobulo_B,
                colorscale: createMulticolorColorscale(),
                opacity: 0.7,
                showscale: false,
                name: 'L√≥bulo B',
                lighting: { ambient: 0.6, diffuse: 0.8 }
            },
            {
                type: 'surface',
                x: Asimut,
                y: Elevacion,
                z: lobulo_C,
                colorscale: createMulticolorColorscale(),
                opacity: 0.7,
                showscale: false,
                name: 'L√≥bulo C',
                lighting: { ambient: 0.6, diffuse: 0.8 }
            },
            {
                type: 'surface',
                x: Asimut,
                y: Elevacion,
                z: lobulo_D,
                colorscale: createMulticolorColorscale(),
                opacity: 0.7,
                showscale: true,
                name: 'L√≥bulo D',
                colorbar: { title: 'Amplitud' },
                lighting: { ambient: 0.6, diffuse: 0.8 }
            }
        ];
        
        Plotly.newPlot('combinados', combinadosData, {
            title: { text: 'Visualizaci√≥n 3D de L√≥bulos', font: { size: 18, weight: 'bold' } },
            scene: {
                xaxis: { title: 'Asimut', gridcolor: '#ddd' },
                yaxis: { title: 'Elevaci√≥n', gridcolor: '#ddd' },
                zaxis: { title: 'Amplitud', gridcolor: '#ddd' },
                camera: cameraView
            },
            margin: { l: 0, r: 0, b: 0, t: 50 },
            paper_bgcolor: 'rgba(0,0,0,0)',
            showlegend: true
        }, { responsive: true });
        
        // ==========================================
        // FIGURA 3: CANALES MONOPULSO 3D (ESF√âRICOS)
        // ==========================================
        
        // Coordenadas esf√©ricas
        const nEsfe = 80; // Reducido para rendimiento
        const asimut_esfe_lin = linspace(-Math.PI/2, Math.PI/2, nEsfe);
        const elevacion_esfe_lin = linspace(-Math.PI/2, Math.PI/2, nEsfe);
        const [asimut_esfe, elevacion_esfe] = meshgrid(asimut_esfe_lin, elevacion_esfe_lin);
        
        const escala = 7;
        const dasimut_esfe = 0.1;
        const delevacion_esfe = 0.1;
        
        // Calcular A, B, C, D en esf√©ricas
        function calcSincEsfe(azi, ele, offsetAzi, offsetEle) {
            const rows = azi.length;
            const cols = azi[0].length;
            const result = [];
            for (let i = 0; i < rows; i++) {
                result[i] = [];
                for (let j = 0; j < cols; j++) {
                    const val = sinc(escala * (azi[i][j] - offsetAzi) / Math.PI) * 
                               sinc(escala * (ele[i][j] - offsetEle) / Math.PI);
                    result[i][j] = val;
                }
            }
            return result;
        }
        
        const A = calcSincEsfe(asimut_esfe, elevacion_esfe, dasimut_esfe, delevacion_esfe);
        const B = calcSincEsfe(asimut_esfe, elevacion_esfe, -dasimut_esfe, delevacion_esfe);
        const C = calcSincEsfe(asimut_esfe, elevacion_esfe, dasimut_esfe, -delevacion_esfe);
        const D = calcSincEsfe(asimut_esfe, elevacion_esfe, -dasimut_esfe, -delevacion_esfe);
        
        // Normalizar
        function normalizeMatrix(m) {
            let maxVal = -Infinity;
            const rows = m.length;
            const cols = m[0].length;
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (Math.abs(m[i][j]) > maxVal) maxVal = Math.abs(m[i][j]);
                }
            }
            const result = [];
            for (let i = 0; i < rows; i++) {
                result[i] = [];
                for (let j = 0; j < cols; j++) {
                    result[i][j] = m[i][j] / maxVal;
                }
            }
            return result;
        }
        
        const A_norm = normalizeMatrix(A);
        const B_norm = normalizeMatrix(B);
        const C_norm = normalizeMatrix(C);
        const D_norm = normalizeMatrix(D);
        
        // Calcular canales
        function absAdd(m1, m2, m3, m4, signs) {
            const rows = m1.length;
            const cols = m1[0].length;
            const result = [];
            for (let i = 0; i < rows; i++) {
                result[i] = [];
                for (let j = 0; j < cols; j++) {
                    let val = signs[0] * m1[i][j] + signs[1] * m2[i][j] + 
                             signs[2] * m3[i][j] + signs[3] * m4[i][j];
                    result[i][j] = Math.abs(val);
                }
            }
            return normalizeMatrix(result);
        }
        
        const sigma = absAdd(A_norm, B_norm, C_norm, D_norm, [1, 1, 1, 1]);
        const asimut_delta = absAdd(A_norm, B_norm, C_norm, D_norm, [1, 1, -1, -1]);
        const elevacion_delta = absAdd(A_norm, B_norm, C_norm, D_norm, [1, -1, 1, -1]);
        const cruzado = absAdd(A_norm, B_norm, C_norm, D_norm, [1, -1, -1, 1]);
        
        // Convertir a cartesianas para visualizaci√≥n 3D
        function toCartesian(r, theta, phi) {
            const rows = r.length;
            const cols = r[0].length;
            const X = [], Y = [], Z = [];
            for (let i = 0; i < rows; i++) {
                X[i] = []; Y[i] = []; Z[i] = [];
                for (let j = 0; j < cols; j++) {
                    X[i][j] = r[i][j] * Math.cos(phi[i][j]) * Math.cos(theta[i][j]);
                    Y[i][j] = r[i][j] * Math.cos(phi[i][j]) * Math.sin(theta[i][j]);
                    Z[i][j] = r[i][j] * Math.sin(phi[i][j]);
                }
            }
            return [X, Y, Z];
        }
        
        const [X_sigma, Y_sigma, Z_sigma] = toCartesian(sigma, asimut_esfe, elevacion_esfe);
        const [X_azimut, Y_azimut, Z_azimut] = toCartesian(asimut_delta, asimut_esfe, elevacion_esfe);
        const [X_elev, Y_elev, Z_elev] = toCartesian(elevacion_delta, asimut_esfe, elevacion_esfe);
        const [X_cruz, Y_cruz, Z_cruz] = toCartesian(cruzado, asimut_esfe, elevacion_esfe);
        
        const commonLayoutEsferico = {
            scene: {
                xaxis: { title: 'x', gridcolor: '#ccc', backgroundcolor: '#e8ecf0' },
                yaxis: { title: 'y', gridcolor: '#ccc', backgroundcolor: '#e8ecf0' },
                zaxis: { title: 'z', gridcolor: '#ccc', backgroundcolor: '#e8ecf0' },
                camera: cameraView,
                aspectmode: 'cube'
            },
            margin: { l: 0, r: 0, b: 0, t: 40 },
            paper_bgcolor: 'rgba(0,0,0,0)'
        };
        
        function createSphericalSurface(X, Y, Z, colorValues, title) {
            return {
                type: 'surface',
                x: X,
                y: Y,
                z: Z,
                surfacecolor: colorValues,
                colorscale: createMulticolorColorscale(),
                showscale: false,
                lighting: {
                    ambient: 0.5,
                    diffuse: 0.8,
                    specular: 0.9,
                    roughness: 0.4
                }
            };
        }
        
        // Sigma
        Plotly.newPlot('sigma', [createSphericalSurface(X_sigma, Y_sigma, Z_sigma, sigma, 'Sigma')], {
            ...commonLayoutEsferico,
            title: { text: 'Sigma', font: { size: 16, weight: 'bold' } }
        }, { responsive: true });
        
        // Azimut
        Plotly.newPlot('azimut', [createSphericalSurface(X_azimut, Y_azimut, Z_azimut, asimut_delta, 'Azimut')], {
            ...commonLayoutEsferico,
            title: { text: 'Azimut', font: { size: 16, weight: 'bold' } }
        }, { responsive: true });
        
        // Elevaci√≥n
        Plotly.newPlot('elevacion', [createSphericalSurface(X_elev, Y_elev, Z_elev, elevacion_delta, 'Elevaci√≥n')], {
            ...commonLayoutEsferico,
            title: { text: 'Elevaci√≥n', font: { size: 16, weight: 'bold' } }
        }, { responsive: true });
        
        // Cruzado
        Plotly.newPlot('cruzado', [createSphericalSurface(X_cruz, Y_cruz, Z_cruz, cruzado, 'Cruzado')], {
            ...commonLayoutEsferico,
            title: { text: 'Cruzado', font: { size: 16, weight: 'bold' } }
        }, { responsive: true });
        
        // ==========================================
        // UTILIDADES
        // ==========================================
        
        function linspace(start, end, n) {
            const arr = [];
            const step = (end - start) / (n - 1);
            for (let i = 0; i < n; i++) {
                arr.push(start + step * i);
            }
            return arr;
        }
        
        console.log('‚úÖ Visualizaciones cargadas correctamente');
        console.log('üìä Par√°metros utilizados:');
        console.log('   - Resoluci√≥n l√≥bulos individuales:', nPoints + 'x' + nPoints);
        console.log('   - Resoluci√≥n coordenadas esf√©ricas:', nEsfe + 'x' + nEsfe);
    </script>
</body>
</html>